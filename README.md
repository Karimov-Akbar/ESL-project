# Workshop 5: HSV Color Picker - nRF52840 Dongle (PCA10059)

Интерактивное устройство для выбора цвета в цветовой модели HSV (Hue, Saturation, Value).

## Описание проекта

Устройство позволяет управлять цветом RGB LED (LD2) через изменение параметров HSV:
- **H (Hue/Оттенок)**: 0-360° - цвет на цветовом круге
- **S (Saturation/Насыщенность)**: 0-100% - интенсивность цвета
- **V (Value/Яркость)**: 0-100% - светлота цвета

## Функциональность

### Начальные значения

При включении устройства:
- **Hue**: Вычисляется из последних двух цифр DEVICE_ID
  - Пример: DEVICE_ID = 1234 → последние цифры 34
  - Hue = 34% × 360° = 122°
- **Saturation**: 100% (полная насыщенность)
- **Value**: 100% (полная яркость)

**Изменение DEVICE_ID:**
```c
// В main.c, строка 16:
#define DEVICE_ID       1234  // Измените на ваш ID
```

### Режимы ввода

Устройство имеет 4 режима, которые переключаются **двойным кликом**:

| Режим | LED1 (индикатор) | Изменяемый параметр | Поведение при удержании кнопки |
|-------|------------------|---------------------|--------------------------------|
| **0: No Input** | Выключен | - | Ничего не изменяется |
| **1: Hue** | Медленное мигание (1 сек) | Оттенок (0-360°) | Плавно изменяется, зацикливается |
| **2: Saturation** | Быстрое мигание (200 мс) | Насыщенность (0-100%) | Плавно изменяется, зацикливается |
| **3: Brightness** | Постоянно горит | Яркость (0-100%) | Плавно изменяется, зацикливается |

### Управление

**Двойной клик (< 400 мс между нажатиями):**
- Переключает режим в последовательности: No Input → Hue → Saturation → Brightness → No Input...

**Удержание кнопки:**
- В режимах 1-3: плавно изменяет выбранный параметр
- Изменение происходит каждые 50 мс
- Значение циклически зацикливается (после максимума → 0)

## Аппаратная конфигурация

### Используемые светодиоды

**LD2 (RGB LED)** - отображает выбранный цвет:
- P0.08 → Красный
- P0.12 → Синий
- P1.09 → Зелёный

**LD1 (Green LED)** - индикатор режима:
- P0.06 → Зелёный индикатор

### Кнопка
- P1.06 → SW1 с pull-up резистором

### PWM модули
- **PWM0**: Управление RGB LED (3 канала)
- **PWM1**: Управление индикатором режима (1 канал)

## Принцип работы

### 1. Цветовая модель HSV

**RGB модель:**
- Red (0-255)
- Green (0-255)  
- Blue (0-255)
- **Проблема**: неинтуитивное управление - сложно подобрать нужный цвет

**HSV модель (предпочтительна для пользовательского интерфейса):**
- **Hue (Оттенок)**: 0-360° - положение на цветовом круге
- **Saturation (Насыщенность)**: 0-100% - "чистота" цвета
- **Value/Brightness (Яркость)**: 0-100% - светлота

```
HSV Cylinder (из лекции):
        
        V=100% (top)
           ↑
           |
    S=0% (center) → S=100% (edge)
           |
        H (0-360°, circular)
           ↓
        V=0% (bottom, black)
```

**Преимущества HSV:**
- Интуитивно понятное управление цветом
- Hue - выбор цвета на цветовом круге (красный→жёлтый→зелёный→голубой→синий→пурпурный)
- Saturation - от серого (0%) до чистого цвета (100%)
- Value - от чёрного (0%) до максимальной яркости (100%)

**Специальные случаи:**
- S=0, любой H → оттенки серого (V определяет яркость)
- V=0, любые H и S → чёрный
- H=0, S=100, V=100 → чистый красный
- H=120, S=100, V=100 → чистый зелёный
- H=240, S=100, V=100 → чистый синий

### 2. Конвертация HSV → RGB

Алгоритм конвертации (реализован в `hsv_to_rgb()`):

```c
C = V × S  // Chroma (цветность)
H' = H / 60°
X = C × (1 - |H' mod 2 - 1|)

Выбор R', G', B' в зависимости от сектора H':
  0° ≤ H < 60°   → (C, X, 0)
  60° ≤ H < 120° → (X, C, 0)
  120° ≤ H < 180° → (0, C, X)
  180° ≤ H < 240° → (0, X, C)
  240° ≤ H < 300° → (X, 0, C)
  300° ≤ H < 360° → (C, 0, X)

m = V - C
R = (R' + m) × 1000  // Конвертация в PWM значение
G = (G' + m) × 1000
B = (B' + m) × 1000
```

### 3. Схема состояний

```
         [Включение]
              ↓
    HSV(H=default, S=100, V=100)
    LED2 = соответствующий цвет
    LED1 = OFF (режим No Input)
              ↓
      [Двойной клик]
              ↓
    Режим Hue: LED1 медленно мигает
              ↓ (удержание кнопки)
    Hue увеличивается: 0° → 1° → ... → 360° → 0°
              ↓
      [Двойной клик]
              ↓
    Режим Saturation: LED1 быстро мигает
              ↓ (удержание кнопки)
    S увеличивается: 0% → 1% → ... → 100% → 0%
              ↓
      [Двойной клик]
              ↓
    Режим Brightness: LED1 постоянно горит
              ↓ (удержание кнопки)
    V увеличивается: 0% → 1% → ... → 100% → 0%
              ↓
      [Двойной клик]
              ↓
    Режим No Input: LED1 выключен
```

## Примеры цветов HSV

| Hue (°) | S (%) | V (%) | Цвет | Описание |
|---------|-------|-------|------|----------|
| 0 | 100 | 100 | Красный | Чистый красный |
| 60 | 100 | 100 | Жёлтый | Чистый жёлтый |
| 120 | 100 | 100 | Зелёный | Чистый зелёный |
| 180 | 100 | 100 | Голубой | Чистый голубой |
| 240 | 100 | 100 | Синий | Чистый синий |
| 300 | 100 | 100 | Пурпурный | Чистый пурпурный |
| 0 | 0 | 100 | Белый | Без насыщенности |
| 0 | 100 | 50 | Тёмно-красный | Половина яркости |
| 0 | 50 | 100 | Розовый | Половина насыщенности |

## Технические детали

### PWM конфигурация

Согласно лекции 9, PWM peripheral в nRF52840:
- **До 4 каналов** на каждый PWM экземпляр (у нас 4 экземпляра: PWM0-PWM3)
- **Расчёт Duty Cycle**: `duty_cycle = value / top_value`
  - Пример: value=500, top=1000 → 50% duty cycle
- **Load mode INDIVIDUAL**: каждый канал имеет своё значение

```c
Частота: 1 MHz / 1000 = 1 kHz
Top value: 1000
Разрешение: 0.1% (1000 шагов)
Режим: UP (счёт вверх)
Загрузка: INDIVIDUAL (отдельные значения для каждого канала)
```

**Используемые PWM экземпляры:**
- **PWM0**: RGB LED (LD2) - 3 канала (R, G, B)
- **PWM1**: Индикатор режима (LD1) - 1 канал (Green)

**Важно:** Для PCA10059 LED подключены активным высоким уровнем, поэтому:
- `value = 0` → LED выключен (0% duty cycle)
- `value = 1000` → LED полная яркость (100% duty cycle)

Если бы LED были с общим анодом, можно было бы использовать **NRFX_PWM_PIN_INVERTED**:
```c
pwm_config.output_pins[0] = LED_RED | NRFX_PWM_PIN_INVERTED;
```

### Временные параметры

```c
DOUBLE_CLICK_TIMEOUT_MS = 400     // Окно двойного клика
DEBOUNCE_MS = 50                  // Антидребезг кнопки
MODE_BLINK_SLOW_MS = 1000         // Медленное мигание (Hue)
MODE_BLINK_FAST_MS = 200          // Быстрое мигание (Saturation)
VALUE_CHANGE_INTERVAL_MS = 50     // Интервал изменения значения
```

### Обработка кнопки

**Комбинированный подход:**

1. **GPIOTE для детекции кликов** - используется прерывание:
```c
NRFX_GPIOTE_CONFIG_IN_SENSE_HITOLO(true)  // Только нажатие (HIGH→LOW)
```
- Детектирует момент нажатия кнопки
- Реализует логику двойного клика
- Легковесный ISR (Interrupt Service Routine)

2. **GPIO Polling для удержания** - проверка в главном цикле:
```c
nrf_gpio_pin_read(BUTTON_PIN)  // Читаем текущее состояние
```
- Каждую 1 мс проверяет, нажата ли кнопка
- Если нажата и активен режим → изменяет значение HSV
- Простой и надёжный способ детекции удержания

**Почему такой подход?**
- GPIOTE идеален для детекции кратковременных событий (клики)
- Polling удобен для длительных состояний (удержание)
- Комбинация даёт лучший результат для этой задачи

**Преимущества:**
- ✅ Точная детекция двойного клика через прерывания
- ✅ Надёжное определение удержания через polling
- ✅ Простая логика без сложной state machine
- ✅ Нет проблем с debounce при удержании

### Конвертация HSV → RGB

**Используется целочисленная арифметика** (без float):
```c
// Разделение цветового круга на 6 секторов (по 60°)
sector = h / 60;  // 0-5
remainder = (h % 60) * 6;  // 0-360

// Расчёт промежуточных значений
p = (v * (100 - s)) / 100
q = (v * (100 - (s * remainder / 360))) / 100
t = (v * (100 - (s * (360 - remainder) / 360))) / 100
```

**Почему целочисленная арифметика?**
- Хотя nRF52840 имеет FPU (Floating Point Unit), целочисленная арифметика:
  - Быстрее для простых операций
  - Не требует библиотеки math.h
  - Предсказуемое поведение
  - Меньше размер кода

### Energy Efficiency

- **Wait For Interrupt (`__WFI`)** - ждёт прерывания
- **Wait For Event (`__WFE`)** - ждёт события  
- **Send Event (`__SEV`)** - отправить событие

Эти инструкции являются **hint instructions** для процессора - они помогают экономить энергию.

В текущей реализации мы используем активный цикл с `nrf_delay_ms(1)` для точного тайминга. 
Для более энергоэффективной версии можно:
1. Использовать **hardware timer** (RTC или TIMER) вместо программного счётчика
2. Вызывать `__WFE()` между обновлениями
3. Использовать **"System Off" sleep mode** для глубокого сна (Nordic специфика)

## Сборка и прошивка

### Компиляция

```bash
# Очистка
make clean

# Сборка (SDK_ROOT и DFU_PORT используют значения по умолчанию)
make

# Если SDK в другом месте, можно указать:
# make SDK_ROOT=/path/to/your/sdk
```

### Прошивка

```bash
# Прошивка через DFU (использует /dev/ttyACM0 по умолчанию)
make dfu

# Если порт другой:
# make dfu DFU_PORT=/dev/ttyACM1

# Найти доступные порты:
ls /dev/ttyACM*
```

### Выходные файлы

```
_build/nrf52840_xxaa.hex    - HEX файл для прошивки
_build/nrf52840_xxaa.bin    - Бинарный файл
_build/nrf52840_xxaa.dfu    - DFU пакет
```